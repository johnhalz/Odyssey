{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Odyssey","text":""},{"location":"#description","title":"Description","text":"<p>Odyssey is a proposal for a modern database structure for hardware production. Thanks to it\u2019s flexible structure, it can accommodate almost any hardware production line with the ability to: - Save data about produced hardware - Keep track of progress - Give users the ability to view live data and control different elements of a production line - Save processes, test results - Keep track of defined specifications and non-compliances</p>"},{"location":"#main-categories","title":"Main Categories","text":"<ul> <li>Development Setup Guide</li> <li>Database Structure</li> <li>API Usage &amp; Documentation</li> </ul>"},{"location":"API/Usage%20%26%20Documentation/","title":"API Usage &amp; Documentation","text":"<p>Odyssey has an extensive REST API that gives developers the ability to integrate it into apps of their choosing. The full documentation of this api is available at: http://localhost:8000/api/schema/swagger-ui/</p>"},{"location":"API/Usage%20%26%20Documentation/#usage-the-api-in-other-languages","title":"Usage the API in Other Languages","text":"<p>Currently, there are no existing packages that can be easily downloaded that interface with Odyssey\u2019s API. They are coming soon though! Packages for the following languages are planned for development though:</p> <ul> <li>Python</li> <li>Swift</li> <li>Rust</li> </ul>"},{"location":"Database/Structure/","title":"Overall Structure","text":"<p>The overall structure of the Odyssey database is shown below:</p> <p> </p>"},{"location":"Database/Structure/#fields","title":"Fields","text":""},{"location":"Database/Structure/#values-units-tables","title":"Values &amp; Units Tables","text":"<p>The values and units tables are one of the big strengths of the Odyssey framework, as they allow efficient and flexible storage of physical measurements in numerical, string or array forms. The units tables categorise units into different types, and conversions between units are accessible through the linear parameters defined with each unit.</p> <p>While a base unit system is provided, users can add more units that are pertinent to their application if they need to.</p>"},{"location":"Database/Structure/#unit-type","title":"Unit Type","text":"<p>This table defines the different types of units that are stored in the Unit table. Each <code>UnitType</code> entry contains the following data:</p> <ul> <li><code>name</code> (Text): The name of the unit type</li> </ul>"},{"location":"Database/Structure/#unit","title":"Unit","text":"<p>As its name implies, the <code>Unit</code> table stores all of the units along with their conversion factors. To simplify unit conversion, we define a base unit for each unit type. For each unit, we then define the factors to convert from that unit back to the base unit. We use the following formula to convert a value in an arbitrary unit \\(x\\) to a value \\(y\\) in the base unit:</p> \\[ y = \\frac{\\left(x + x_{offset} \\right) \\cdot multiplicand}{denominator} + y_{offset} \\] <p>Each <code>Unit</code> entry stores the following data: - <code>name</code> (Text): The name of the unit - <code>plural_name</code> (Text): The plural name of the unit - <code>space_after_value</code> (Boolean): This field specifies if a space should be added between the value and the unit when printing the quantity (value and unit) - <code>base_unit</code> (<code>Unit</code>): Link to the base unit of the unit type (will be null if the entry is the base unit) - <code>abbreviation</code> (Text): Unit abbreviation - <code>create_ts</code> (Date &amp; Time): When this entry was created - <code>x_offset</code> (Decimal): value - <code>y_offset</code> (Decimal): value - <code>multiplicand</code> (Decimal): value - <code>denominator</code> (Decimal): value</p>"},{"location":"Database/Structure/#value","title":"Value","text":"<p>As multiple different types of values can be stored (strings, integers, decimal numbers and array), the <code>Value</code> table offers a single point where users can access this data. We have created this table so that developers that interact with Odyssey and its APIs have a high-performance (database-level) access point to values of any type (hence removing any logic that would required to check the desired type before querying the database). This can become very useful when searching for values, and is already used within the Odyssey database when another table links to a value.</p> <p>Each <code>Value</code> entry is automatically created in the database when a new <code>String</code>, <code>Integer</code>, <code>Decimal</code> or <code>Array</code> is created and each <code>Value</code> entry contains the following data:</p> <ul> <li><code>content_type</code>: The type of content that the entry is linking to (needed for database logic)</li> <li><code>object_id</code> (Integer): The id of the object we are linking to</li> <li><code>content_object</code>: This is the content of the object (this is what developers would need to access through this table)</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#string","title":"String","text":"<p>The <code>String</code> table contains all of the stored strings that are to be used as values. While using strings for containing numerical values is discouraged (there are specific tables for this). The odd case can still arise where a string is the only possible usable type.</p> <p>Each <code>String</code> entry stores the following data:</p> <ul> <li><code>string</code> (Text): The text of the string</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>value</code> (<code>Value</code>): The value that the entry is connected to</li> </ul>"},{"location":"Database/Structure/#integer","title":"Integer","text":"<p>The <code>Integer</code> table stores integer values that can be linked to a unit (although this is optional).</p> <p>Each <code>Integer</code> entry stores the following data:</p> <ul> <li><code>integer</code> (Integer): Integer value</li> <li><code>unit</code> (<code>Unit</code>): A linked unit (can be left blank)</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>value</code> (<code>Value</code>): The value that the entry is connected to</li> </ul>"},{"location":"Database/Structure/#decimal","title":"Decimal","text":"<p>The <code>Decimal</code> table stores any float number that can be linked to a unit (although this is optional).</p> <p>Each <code>Decimal</code> entry stores the following data:</p> <ul> <li><code>decimal</code> (Float): The decimal number's value</li> <li><code>unit</code> (<code>Unit</code>): A linked unit (can be left blank)</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>value</code> (<code>Value</code>): The value that the entry is connected to</li> </ul>"},{"location":"Database/Structure/#array","title":"Array","text":"<p>The <code>Array</code> table stores any array of numbers that can be linked to a unit (although this is optional).</p> <p>Each <code>Array</code> entry stores the following data:</p> <ul> <li><code>array</code> (<code>Array[Float]</code>): The array value</li> <li><code>unit</code> (<code>Unit</code>): A linked unit (can be left blank)</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>value</code> (<code>Value</code>): The value that the entry is connected to</li> </ul>"},{"location":"Database/Structure/#version","title":"Version","text":"<p>As configurations, software and hardware typically have versions assigned to them, we create a <code>Version</code> table to store all of these versions. We enforce the use of semantic versioning numbers with major, minor and patch number values.</p> <p>Each <code>Version</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): An associated name of the version</li> <li><code>major</code> (Integer): The major version number</li> <li><code>minor</code> (Integer): The minor version number</li> <li><code>patch</code> (Integer): The patch version number</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>description</code> (Text): An optional description of the version</li> </ul>"},{"location":"Database/Structure/#range","title":"Range","text":"<p>Typically when defining specifications, different ranges are defined that give a minimum and maximum bounds to the spec. The <code>Range</code> table is meant to hold such data.</p> <p>Each <code>Range</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): Name of the range</li> <li><code>lower</code> (<code>Value</code>): Lower value</li> <li><code>upper</code> (<code>Value</code>): Upper value</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#hardware-tables","title":"Hardware Tables","text":""},{"location":"Database/Structure/#hardware-model","title":"Hardware Model","text":"<p>The <code>HardwareModel</code> table is meant to store the model of the assembled hardware. It is meant to store the assembly logic (which part goes where, and where different sub-assemblies are).</p> <p>Each <code>HardwareModel</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): The name of the hardware in question</li> <li><code>position</code> (Text): The position of the hardware in its assembly</li> <li><code>parent</code> (<code>HardwareModel</code>): The parent assembly (this will be empty if this is the top assembly)</li> <li><code>version</code> (<code>Version</code>): The version of this part</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#hardware","title":"Hardware","text":"<p>The <code>Hardware</code> table is meant to store all of the instances of physical hardware that were built. Each <code>Hardware</code> element is meant to reference a <code>HardwareModel</code> entry.</p> <p>Each <code>Hardware</code> entry stores the following data:</p> <ul> <li><code>serial_number</code> (Text): The serial number (or part number) of the hardware</li> <li><code>model</code> (<code>HardwareModel</code>): The hardware model the this entry references</li> <li><code>set</code> (Integer): The set in which this entry belongs</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#order","title":"Order","text":"<p>As hardware can be treated in different ways in production, (initial build-up, repair, service, etc.), we create order numbers to keep track of the different types of treatment a piece of hardware with the same serial number can go through. We call these <code>Order</code> numbers.</p> <p>Each <code>Order</code> entry stores the following data:</p> <ul> <li><code>number</code> (Integer): Order number</li> <li><code>hardware</code> (<code>Hardware</code>): Link to the hardware in question</li> <li><code>order_type</code> (Text): The type of order we are fulfilling</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#equipment","title":"Equipment","text":"<p>Throughout production, different equipment is used. Typically in a production environment we wish to keep track of the equipment used. This is what the <code>Equipment</code> table is for.</p> <p>Each <code>Equipment</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): Name of equipment</li> <li><code>number</code> (Integer): Equipment number (in case there are more than one of the same equipment)</li> <li><code>calibration_ts</code> (Date &amp; Time): Date and time of when the equipment was last calibrated</li> <li><code>parent</code> (<code>Equipment</code>): The parent equipment (this will be empty if this is the top assembly)</li> <li><code>status</code> (Text): This field is meant to show if the equipment is being used, in calibration, or is free to use</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#production-tables","title":"Production Tables","text":""},{"location":"Database/Structure/#production-step-model","title":"Production Step Model","text":"<p>Assembly and testing of hardware does not happen in a single step! The <code>ProductionStepModel</code> table is meant to hold all of the steps required for any assembly, repair, calibration or service procedure. Similarly to <code>HardwareModel</code>, it contains all of the entries that the production steps will refer to.</p> <p>Each <code>ProductionStepModel</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): The name of the production step model</li> <li><code>parent</code> (<code>ProductionStepModel</code>): The parent step model (so sub-steps can be added if necessary)</li> <li><code>version</code> (<code>Version</code>): The version of this step model entry</li> <li><code>step_number</code> (Integer): The step number (so that the order of each entry can be saved)</li> <li><code>optional</code> (Boolean): Marker if the step is optional or not</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#production-step","title":"Production Step","text":"<p>The <code>ProductionStep</code> table is meant to store all of the production steps that actually happened. This allows the production team to keep track of where each piece of hardware that is being built is, and what progress is being made.</p> <p>Each <code>ProductionStep</code> entry stores the following data:</p> <ul> <li><code>order</code> (<code>Order</code>): The order of the hardware in question</li> <li><code>production_step_model</code> (<code>ProductionStepModel</code>): The production step model that this production step refers to</li> <li><code>status</code> (Text): The current status of this production step</li> <li><code>operator</code> (<code>User</code>): The operator executing this step</li> <li><code>start_ts</code> (Date &amp; Time): The date and time of when this production step was started</li> <li><code>end_ts</code> (Date &amp; Time): The date and time of when this production step was completed</li> </ul>"},{"location":"Database/Structure/#configuration","title":"Configuration","text":"<p>As with any automated handling of hardware, the configuration of an assembly tool, testing jig, or other material can have different configurations set. This is what the <code>Configuration</code> table is meant to store.</p> <p>Each <code>Configuration</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): The name of the configuration</li> <li><code>parent</code> (<code>Configuration</code> ): The parent configuration</li> <li><code>value</code> (<code>Value</code>): The value of the configuration</li> <li><code>hardware_model</code> (<code>HardwareModel</code>): The hardware model that this configuration applies to</li> <li><code>production_step_model</code> (<code>ProductionStepModel</code>): The production step model that this configuration applies to</li> <li><code>version</code> (<code>Version</code>): The version of the configuration</li> <li><code>description</code> (Text): Description of the configuration</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#testing-tables","title":"Testing Tables","text":"<p>Throughout production, various tests are run on the hardware in question to ensure a certain level of quality specified by the intended customer. The tables below are meant to store this data as well as any non-compliances that can come up.</p>"},{"location":"Database/Structure/#measurement","title":"Measurement","text":"<p>The purpose of this table is self-explanatory (it stores the measurements taken on a specific piece of hardware).</p> <p>Each <code>Measurement</code> entry stores the following data:</p> <ul> <li><code>parent</code> (<code>Measurement</code>): The parent measurement</li> <li><code>name</code> (Text): The name of the measurement</li> <li><code>value</code> (Value): The value of the measurement</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>production_step</code> (<code>ProductionStep</code>): The production step in which this measurement was taken</li> </ul>"},{"location":"Database/Structure/#specification","title":"Specification","text":"<p>Each measurement that is taken is usually compared with a pre-defined specification, which is what the <code>Specification</code> table stores.</p> <p>Each <code>Specification</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): The name of the specification</li> <li><code>valid_range</code> (<code>Range</code>): The range in which we consider a measurement to be valid</li> <li><code>applicable_scope</code> (<code>Range</code>): The range in which we would want to check if a measurement is within the valid range</li> <li><code>hardware_model</code> (<code>HardwareModel</code>): The hardware to which the specification applies to</li> <li><code>production_step_model</code> (<code>ProductionStepModel</code>): The production step model that the specification applies to</li> <li><code>group</code> (<code>SpecificationGroup</code>): The specification group that this specification belongs to</li> <li><code>description</code> (Text): Description of this specification</li> <li><code>severity</code> (Text): How important this specification is</li> <li><code>version</code> (<code>Version</code>): The version of this specification</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#specification-group","title":"Specification Group","text":"<p>As many specifications can be defined and are typically linked together, the <code>SpecificationGroup</code> table allows the data owner to create different groups to link each specification together.</p> <p>Each <code>SpecificationGroup</code> entry stores the following data:</p> <ul> <li><code>name</code> (Text): The name of the group</li> <li><code>commencement_date</code> (Date &amp; Time): The date and time that this group's specifications come into effect</li> <li><code>expiration_date</code> (Date &amp; Time): The date and time that this group's specifications expire</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#result","title":"Result","text":"<p>Typically, each raw measurement (or a group of measurements) is processed into a resulting value, which is then compared with a list of specifications. The <code>Result</code> table is meant to hold onto this processed data.</p> <p>Each <code>Result</code> entry stores the following data:</p> <ul> <li><code>parent</code> (<code>Result</code>): The parent result</li> <li><code>name</code> (Text): The name of the result</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>measurements</code> (<code>Measurement</code> - Many-to-Many): List of measurements this result was computed from</li> <li><code>specification</code> (<code>Specification</code>): The specification that this result should satisfy</li> <li><code>value</code> (Value): The value of this result</li> <li><code>processor</code> (<code>Processor</code>): The processor (that took the input measurements and computed this result)</li> </ul>"},{"location":"Database/Structure/#non-compliance","title":"Non-Compliance","text":"<p>A non-compliance (or NC for short) is created when a result does not meet a specification. The <code>NonCompliance</code> table holds all of these entries.</p> <p>Each <code>NonCompliance</code> entry stores the following data:</p> <ul> <li><code>result</code> (<code>Result</code>): The associated result</li> <li><code>status</code> (Text): Indicator to mark if the non-compliance has been resolved, is under review, being resolved, etc.</li> <li><code>decision</code> (Text): Text describing the decision made (preferably including the reason why) (mostly for documentation purposes)</li> <li><code>reporter</code> (<code>User</code>): The user that reported the non-compliance</li> <li><code>signer</code> (<code>User</code>): The user that signed to make the final decision on the non-compliance</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>close_ts</code> (Date &amp; Time): When the non-compliance was closed</li> </ul>"},{"location":"Database/Structure/#non-compliance-comment","title":"Non-Compliance Comment","text":"<p>Every non-compliance would usualy spark a new discussion. This table is meant to hold the comments made on an NC.</p> <p>Each <code>NonComplianceComment</code> entry stores the following data:</p> <ul> <li><code>parent</code> (<code>NonComplianceComment</code>): The parent comment (if it exists)</li> <li><code>non_compliance</code> (<code>NonCompliance</code>): The non-compliance entry that this comment refers to</li> <li><code>author</code> (<code>User</code>): The author of the comment</li> <li><code>content</code> (Text): The content of the comment</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> </ul>"},{"location":"Database/Structure/#processor","title":"Processor","text":"<p>As each measurement (or multiple measurements) might need to be post-processed into a result, the <code>Processor</code> table keeps track of the different post-processing scripts and actions that are taken for each measurement.</p> <p>Each <code>Processor</code> entry contains the following data:</p> <ul> <li><code>name</code> (Text): The name of the processor</li> <li><code>create_ts</code> (Date &amp; Time): When this entry was created</li> <li><code>version</code> (<code>Version</code>): The version of the processor</li> <li><code>production_step_model</code> (<code>ProductionStepModel</code>): The production step model that this processor refers to</li> <li><code>file_path</code> (File path): The file path of the post-processing script</li> </ul>"},{"location":"Development%20Setup%20Guide/Database%20Setup/","title":"Database Setup","text":"<p>Odyssey uses a Postgres database to store data. Currently, it is recommended to use Docker to set up a Postgres database. You can use the following command to create a Postgres database in Docker:</p> <pre><code>docker run --name odyssey -e POSTGRES_PASSWORD=odysseypassword -d -p 5432:5432 postgres\n</code></pre> <p>You can set the password to the database by setting the <code>POSTGRES_PASSWORD</code> field.</p> <p>Note</p> <p>If you change the value of <code>POSTGRES_PASSWORD</code>, you will also need to edit this value in the <code>Odyssey/settings.py</code> file (lines 79 - 88).</p> <p>Now that you have your database, you can move onto setting up your python development environment!</p>"},{"location":"Development%20Setup%20Guide/Making%20Migrations%20%26%20Adding%20Seed%20Data/","title":"Making Migrations &amp; Adding Seed Data","text":""},{"location":"Development%20Setup%20Guide/Making%20Migrations%20%26%20Adding%20Seed%20Data/#making-migrations","title":"Making Migrations","text":"<p>Now that your database and python environment are setup, you will now need to setup your database with the data models that are defined within the Odyssey project. You can do by simply running the following commands.</p> <p>Note</p> <p>Make sure your python virtual environment is activated before running these commands. You can activate the environment by cding into the project folder and running the command:</p> <pre><code>poetry shell\n</code></pre> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"Development%20Setup%20Guide/Making%20Migrations%20%26%20Adding%20Seed%20Data/#adding-seed-data","title":"Adding Seed Data","text":"<p>To make onboarding easier, we have created seed data to help you get started. This is the case for the unit types, and units themselves. Of course, you can add your own units after the fact in case you need more specialised units for your use case.</p> <p>You can onboard this data by running the following commands:</p> <pre><code>cd &lt;path-to-odyssey-folder&gt;\n\n# Load the unit types\npython manage.py loaddata values_and_units/fixtures/unit_types.json\n\n# Load the units\npython manage.py loaddata values_and_units/fixtures/units.json\n</code></pre> <p>After setting up a superuser account and accessing the admin page, you will be able to see the seed data in their respective tables in the admin page.</p>"},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/","title":"Python Environment Setup","text":"<p>As Odyssey is a Django project (written in python). It is recommended to use a virtual environment to handle the project's dependencies.</p>"},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/#installing-python","title":"Installing Python","text":"<p>To install python on your machine, it is recommended to use pyenv (or pyenv-win for Windows).</p> <p>After having installed pyenv, you can install a specific version on your machine by running:</p> <pre><code>pyenv install 3.11.7\n</code></pre> <p>We recommend to install python 3.11.7 or later, as Odyssey was built using python 3.11.7.</p>"},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/#creating-a-virtual-environment-with-poetry","title":"Creating a Virtual Environment with Poetry","text":""},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/#installing-poetry","title":"Installing Poetry","text":"<p>For creating a virtual environment, we recommend to use poetry, as Odyssey was built using this tool as well.</p> <p>After having installed Poetry on your system, it is highly recommended to enable the <code>virtualenvs.in-project</code> configuration option. You can do this by running the following command:</p> <pre><code>poetry config virtualenvs.in-project true\n</code></pre> <p>This will make Poetry create <code>.venv</code> files in the project folder, making it much easier to manage the virtual environments that Poetry creates.</p>"},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/#installing-dependencies-and-creating-virtual-environment","title":"Installing Dependencies and Creating Virtual Environment","text":"<p>After having cloned this repo, you can install all dependencies and create a virtual environment by just running the command:</p> <pre><code>cd &lt;path-to-odyssey-folder&gt;\npoetry install --group dev\n</code></pre> <p>This will install all required dependencies (listed in the <code>pyproject.toml</code> file).</p> <p>All that\u2019s left now is to add the seed data to the database!</p>"},{"location":"Development%20Setup%20Guide/Python%20Environment%20Setup/#reference-links","title":"Reference Links:","text":"<ul> <li>pyenv Documentation (README)</li> <li>poetry Documentation</li> </ul>"},{"location":"Development%20Setup%20Guide/Running%20Server%20%26%20Creating%20an%20Admin%20Account/","title":"Running Server &amp; Creating an Admin Account","text":""},{"location":"Development%20Setup%20Guide/Running%20Server%20%26%20Creating%20an%20Admin%20Account/#running-server","title":"Running Server","text":"<p>You can run the server with the command:</p> <pre><code>python manage.py runserver\n</code></pre> <p>This command will output the address from which you can access Odyssey on your browser. For local deployments, this will most likely be http://127.0.0.1:8000.</p>"},{"location":"Development%20Setup%20Guide/Running%20Server%20%26%20Creating%20an%20Admin%20Account/#creating-an-admin-account","title":"Creating an Admin Account","text":"<p>To access the admin page on your local deployment, go to http://127.0.0.1:8000/admin. You will need to create a login to be able to login, which you can do by running the command:</p> <pre><code>python manage.py createsuperuser\n</code></pre> <p>which will then prompt you to create a username and password, you will then be able to log into the admin page.</p>"}]}